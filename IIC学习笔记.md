# IIC学习笔记 



## 1、IIC总线通信过程

1、主机发送起始信号启用总线；

2、主机发送一个字节数据指明从机地址和后续字节的传送方向；（如果最后一位为0则为主向从发，为1则相反）

3、被寻址的从机发送应答信号回应主机；

4、发送器发送一个字节数据；

5、接收器发送应答信号回应发送器；

6、（循环步骤4、5）；

n、通信完成后主机发送停止信号释放总线；

***



SDA：数据线    SCL：时钟线   原文链接：https://blog.csdn.net/hu_junhua/article/details/79269891

* 每个连接到IIC总线上的器件都是有唯一的地址；

  ## 1、起始信号和终止信号

* 1.**起始信号** i2c_Start()：当SCL线为高电平期间，SDA线由**高电平**向**低电平**变化就表示**起始信号**；

  参考代码  

  ```c
    void i2c_Start(void)
  
    { /* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */   
  
  ​      SDA = 1;   
  
  ​      SCL = 1;    
  
  ​	  i2c_Delay();   
  
  ​	  SDA = 0;  
  
  ​	  i2c_Delay();    
  
  ​	   SCL = 0;    
  
  ​	   i2c_Delay();
  
   }
  ```

  

2.**终止信号** i2c_Stop():当SCL线为高电平期间，SDA线由**低电平**向**高电平**转换就表示**终止信号**

   参考代码   

```c
void i2c_Stop(void)

​					 {    /* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */    

​					SDA = 0;    

​					SCL = 1;   

​		 			i2c_Delay();   

​					 SDA = 1;    

​					i2c_Delay(); 

​					}
```



## 2、应答与非应答 

IIC总线的协议规定，每传输一个字节的数据后，都要有一个应答信号以确定书记传输是否被对方接收。应答信号由接受设备产生，在SCL为高电平时，接收设备将SDA拉低为低电平，表示数据传输正确，产生应答。7.等待应答 i2c_WaitAck()

/*
*********************************************************************************************************
*   函 数 名: i2c_WaitAck
*   功能说明: CPU产生一个时钟，并读取器件的ACK应答信号
*   形    参:  无
*   返 回 值: 返回0表示正确应答，1表示无器件响应
*********************************************************************************************************
*/

```c
unsigned char i2c_WaitAck(void)
{
     unsigned char re; //应答信号等于0则应答正确，等于1则没有应答
     SDA = 1;          //释放总线，能让对方拉低
     i2c_Delay();
     SCL = 1;          //此时刻开始，数据保持应答状态稳定
     i2c_Delay();
     if(SDA == 1)
     {
        re = 1;        //没有应答
     }
     else
     {
        re = 0;        //应答正确                                                                                                                                                                            
     }
     SCL = 0;
     i2c_Delay();
    
     return re;
}
```

## 3、IIC的数据传送

​	时钟线SCL为低电平期间发送器向数据线上发送一位数据，在此期间数据线上的信号允许发生变化，时钟线SCL为高电平期间接收器从数据线上读取一位数据，在此期间数据线上的信号不允许发生变化，必须保持稳定；

* **写数据 i2c_SendByte()**

  *********************************************************************************************************
  *   函 数 名: i2c_SendByte
  *   功能说明: CPU向I2C总线设备发送8bit数据
  *   形    参:  _ucByte ： 等待发送的字节
  *   返 回 值: 无
  *********************************************************************************************************
  

  ```c
  void i2c_SendByte(unsigned char _ucByte)
  {
       unsigned char i;     //其实信号开始后SCL是被拉低的
       for(i = 0; i < 8; i++)
       {
          if(_ucByte & 0x80)
              SDA = 1;
          else
              SDA = 0;
          SCL = 1; 
          i2c_Delay();
          SCL = 0;      //SCL等于0的时候写数据
          if(i == 7)    //最后一次时释放总线
          {
              SDA = 1;
          }
          _ucByte<<=1;  //左移一位
          i2c_Delay();
       }
  }
  ```

  **读数据 i2c_ReadByte（)**

  *********************************************************************************************************
  *   函 数 名: i2c_ReadByte
  *   功能说明: CPU从I2C总线设备读取8bit数据
  *   形    参:  无
  *   返 回 值: 读到的数据
  *********************************************************************************************************

  

  ```c
  unsigned char i2c_ReadByte(void)
  {
       unsigned char i;
       unsigned char value = 0;
       for(i = 0; i < 8; i++)
       {
          value<<=1;
          SCL = 1;  //稳定状态的时候读数据
          if(SDA == 1)
              value++;
          SCL = 0;  //允许数据变化
          i2c_Delay();
       } 
      return value;
      }
  ```
  

  ## 发送应答信号与非应答信号

  * **发送应答信号 i2c_Ack()**

    /*
    *********************************************************************************************************
    *   函 数 名: i2c_Ack
    *   功能说明: CPU产生一个ACK信号
    *   形    参:  无
    *   返 回 值: 无
    *********************************************************************************************************
    */

    ```c
    void i2c_Ack(void)
    {
        SDA = 0;//响应
        i2c_Delay();
        SCL = 1;
        i2c_Delay();
        SCL = 0;
        i2c_Delay();   //在SCL为高电平期间SDA都为0即产生一个应答信号
        SDA = 1;       //释放总线
        i2c_Delay();
    }
    ```

    **发送非应答信号 i2c_Nack()**

    /*

    *********************************************************************************************************
    *   函 数 名: i2c_NAck
    *   功能说明: CPU产生1个NACK信号
    *   形    参:  无
    *   返 回 值: 无
    *********************************************************************************************************
    */

    ```c
    void i2c_NAck(void)
    {
         SDA = 1;
         i2c_Delay();
         SCL = 1;
         i2c_Delay();
         SCL = 0;
         i2c_Delay();   //在SCL为高电平期间SDA都为1即产生一个非应答信号
    }
    ```

    

8.检测I2C总线设备 i2c_CheckDevice



