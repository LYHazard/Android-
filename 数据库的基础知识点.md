# 数据库的基础知识点

## 1.数据库的ACID

1.原子性

是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。

可采用“A向B转账”这个例子来说明解释

在DBMS中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。

2.一致性

一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。

如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。

保障机制（也从两方面着手）：数据库层面会在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,check约束等)和触发器设置；此外，数据库的内部数据结构（如 B 树索引或双向链表）都必须是正确的。业务的一致性一般由开发人员进行保证，亦可转移至数据库层面。

3.隔离性

多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。

在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。

4.持久性

这是最好理解的一个特性：持久性，意味着在事务完成以后，**该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。**（完成的事务是**系统永久的部分**，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持）

## 2. 数据库的日志

REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性）

UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）

## 3.数据库的扩展

数据库扩展大概分为以下几个步骤： 
1、读写分离：当数据库访问量还不是很大的时候，我们可以适当增加服务器，数据库主从复制的方式将读写分离； 

2、垂直分区：当写入操作一旦增加的时候，那么主从数据库将花更多的时间的放在数据同步上，这个时候服务器也是不堪重负的；那么就有了数据的垂直分区，数据的垂直分区思路是将写入操作比较频繁的数据表，如用户表_user,或者订单表_orders,那么我们就可以把这个两个表分离出来，放在不同的服务器，如果这两个表和其他表存在联表查询，那么就只能把原来的sql语句给拆分了，先查询一个表，在查询另一个，虽然说这个会消耗更过性能，但比起那种大量数据同步，负担还是减轻了不少； 

3、水平分区：但是往往事情不尽人意，可能采取垂直分区能撑一段时间，由于网站太火了，访问量又每日100w,一下子蹦到了1000w,这个时候可以采取数据的进行分离，我们可以根据user的Id不同进行分配，如采取%2的形式，或者%10的形式，当然这种形式对以后的扩展有了很大的限制，当我由10个分区增加到20个的时候，所有的数据都得重新分区，那么将是一个的很庞大的计算量；以下提供几种常见的算法： 
  哈希算法：就是采用user_id%的方式; 
  范围：可以根据user_id字符值范围分区，如1-1000为一区，1001-2000则是另一个区等； 
  映射关系：就是将user_id存在的所对应的分区放在数据库中保存，当用户操作时先去查询所在分区，再进行操作； 

  对于以上几种扩展方式，读写分离主要是操作上的扩展，垂直分区主要是对写入较频繁数据表的分离，水平分区主要是数据分离；

Oplog 概念
Oplog 是用于存储 [MongoDB](https://so.csdn.net/so/search?q=MongoDB&spm=1001.2101.3001.7020) 数据库所有数据的操作记录的(实际只记录增删改和一些系统命令操作，查是不会记录的)，有点类似于 mysql 的 binlog 日志。

